from manim import *
from manim_voiceover import VoiceoverScene
from manim_voiceover.services.recorder import RecorderService

from math import sqrt, pi, e, log

config.background_color = rgb_to_color([28/255, 35/255, 31/255])

class FreeGroupTreeScene(VoiceoverScene):
    def construct(self):
        self.set_speech_service(RecorderService(silence_threshold=-40.0))

        title_card_tex = Tex(r"The free group $F_2$", font_size = 60)
        
        s = "One of the essential constructions in the proof of the Banach-Tarski paradox is the use of the free group to “duplicate” the ball. We will see that the free group generated by two elements can be easily divided into parts, such that they can be shifted to create two copies of itself. This is in essence what we wil eventually be doing with the unit ball  as well. So what is the free group?"

        with self.voiceover(s):
            self.play(Write(title_card_tex))

        s = "Let's look at a definition. The free group f two generated by two elements sigma and tau is the group consisting of all finite products of sigma, tau and their inverses. The identity in this group is the empty product."
        f2_definition_tex = Tex(r"\textbf{Definition (Free Group $F_2$)}. The free group $F_2$ generated by two elements $\sigma, \tau$ is the group consisting of all finite products of $\sigma, \tau$ and their inverses $\sigma^{-1}, \tau^{-1}$. The identity in this group is the empty product (denoted $e$).").scale(.75)

        with self.voiceover(s):
            self.play(
                title_card_tex.animate.to_edge(UP)
            )
            self.play(FadeIn(f2_definition_tex))

        s = "These are some examples of elements."
        example_elements_tex = Tex(r"Ex.: $\sigma\tau$, $\tau^2\sigma^{-1}$, $\sigma\tau\sigma\tau^{-2}\sigma$, etc.").next_to(f2_definition_tex, DOWN).shift(DOWN * .75)

        self.wait(.5 )

        with self.voiceover(s):
            self.play(
                Write(example_elements_tex)
            )


        root = MathTex(r"e")
        leaves_1 = []
        branches_1 = []
        for i, label in enumerate((r"\sigma", r"\tau", r"\sigma^{-1}", r"\tau^{-1}")):
            leaf = MathTex(label).shift(1.5*DOWN + i * RIGHT*2 - 3 * RIGHT)
            leaf_branch = Arrow(start = root, end = leaf)
            # leaf_branch_label = MathTex(label).next_to(leaf_branch, LEFT)#.shift(LEFT * .5)
            leaves_1.append(leaf)
            branches_1.append(leaf_branch)

        tree = VGroup(root, *leaves_1, *branches_1).to_edge(UP)

        leaves_2 = []
        branches_2 = []
        for i, label in enumerate((r"\sigma^2", r"\sigma\tau", r"\sigma\tau^{-1}")):
            leaf = MathTex(label).shift(i * RIGHT*2 - 3 * RIGHT)
            leaf_branch = Arrow(start = leaves_1[0], end = leaf)
            # leaf_branch_label = MathTex(label).next_to(leaf_branch, LEFT)#.shift(LEFT * .5)
            leaves_2.append(leaf)
            branches_2.append(leaf_branch)
        tree.add(*leaves_2, *branches_2)
        
        leaves_3 = []
        branches_3 = []
        for i, label in enumerate(
                (r"\sigma\tau\sigma", r"\sigma\tau^2", r"\sigma\tau\sigma^{-1}")
            ):
            leaf = MathTex(label).shift(2 * DOWN + i * RIGHT*2 - 3 * RIGHT)
            leaf_branch = Arrow(start = leaves_2[1], end = leaf)
            # leaf_branch_label = MathTex(label).next_to(leaf_branch, LEFT)#.shift(LEFT * .5)
            leaves_3.append(leaf)
            branches_3.append(leaf_branch)
        tree.add(*leaves_3, *branches_3)
        
        
        tree_text = Tex(r"$F_2$ as a tree").to_corner(UP + LEFT)

        s = "One way to look at this group is to consider it as a directed tree. At the root of the tree, we have the identity element e. We can then go further down the tree by multiplying on the right with sigma, tau, sigma inverse  or tau inverse."
        with self.voiceover(s):
            self.play(
                    FadeOut(title_card_tex, f2_definition_tex, example_elements_tex),
                    Create(tree),
                    FadeIn(tree_text),
                    run_time = 2.5           
                )
            
        s = "Each step down the tree is a multiplication on the right by some element of F2. Note that we can't show the whole tree, since it is infinitely big. We only show the progression of the tree for elements starting with sigma, then starting with sigma tau. You should imagine the tree continuing infinitely for all the other branches as well. "

        with self.voiceover(s):
            self.wait(0.5)

        f2_decomp_tex = MathTex(r"F_2 = {{ \{e\} }} \cup {{W(\sigma)}} \cup {{W(\sigma^{-1})}} \cup {{W(\tau)}} \cup {{W(\tau^{-1})}}", font_size = 35).next_to(tree, DOWN, buff = 0.5)
        tree = VGroup(tree, f2_decomp_tex)

        s = "We can represent the same thing symbolically as follows. F2 can be written as"
        with self.voiceover(s):
            pass

        s = "the disjoint union of the empty word, all the elements starting with sigma, the elements starting with sigma inverse, the elements starting with tau, and the elements starting with tau inverse. The notation W of sigma means: the elements starting with sigma."
        with self.voiceover(s):
            self.play(ShowIncreasingSubsets(f2_decomp_tex), run_time = 5)

        sigma_tree = VGroup(leaves_1[0], *leaves_2, *leaves_3, *branches_2, *branches_3) 
        sigma_tree_copy = sigma_tree.copy().move_to(sigma_tree.get_center())
        sigma_tree_leaves = VGroup(leaves_1[0], *leaves_2, *leaves_3)
        sigma_tree_copy_leaves = [m for m in sigma_tree_copy if type(m) == MathTex]

        f2_decomp_tex_sigma = MathTex(r"W(\sigma)").next_to(sigma_tree_copy, DOWN, buff = 0.5)
        sigma_tree_copy = VGroup(sigma_tree_copy, f2_decomp_tex_sigma)

        s = "Now let's take a closer look at the branch that has elements starting with sigma."
        with self.voiceover(s):
            self.play(
                LaggedStartMap(Indicate, sigma_tree_leaves, run_time = 2)
            )
            self.play(
                LaggedStartMap(Indicate, sigma_tree_leaves, run_time = 2)
            )
            self.play(
                tree.animate.to_edge(LEFT), 
                # f2_decomp_tex.animate.to_edge(LEFT),
                FadeOut(tree_text)
            )
            # self.play(f2_decomp_tex.animate.scale(.5), run_time=0.5)
            self.play(
                sigma_tree_copy.animate.to_edge(RIGHT),
                # f2_decomp_tex_sigma.animate.to_edge(RIGHT)    
            )

        self.wait(2)

        new_leaves = [
            r"e",
            r"\sigma", r"\tau", r"\tau^{-1}",
            r"\tau\sigma", r"\tau^{2}", r"\tau\sigma^{-1}"
        ]
        sigma_inv_tex = MathTex(r"\sigma^{-1}", color=BLUE).next_to(f2_decomp_tex_sigma, LEFT, buff = 0.07)
        s = "Notice that when, for all these elements, we multiply on the left by sigma inverse, we get the whole tree again!"
        with self.voiceover(s):
            self.play(FadeIn(sigma_inv_tex))
            notice_group = VGroup(sigma_inv_tex, f2_decomp_tex_sigma)
            self.play(Circumscribe(notice_group), run_time=2)
            self.wait(2)
            for i, leaf in enumerate(sigma_tree_copy_leaves):
                leaf_sigma_inv_tex = MathTex(r"\sigma^{-1}", font_size = 42, color=BLUE).next_to(leaf, LEFT, buff = 0.07).shift(UP * 0.03)
                self.play(Write(leaf_sigma_inv_tex), run_time=0.7)
                replacement_leaf = MathTex(new_leaves[i]).move_to(leaf.get_center())
                self.play(
                    FadeOut(leaf_sigma_inv_tex),
                    Transform(leaf, replacement_leaf),
                    run_time=0.7
                )
        
        s = "Or rather, we get almost the whole tree. The part of the tree that shows elements starting with sigma inverse is not there!"
        with self.voiceover(s):
            self.wait(3)
        
        self.play(FadeOut(*self.mobjects))

        self.wait(2)

