from manim import *
from manim_voiceover import VoiceoverScene
from manim_voiceover.services.gtts import GTTSService
from math import sqrt, pi, e, log

config.background_color = rgb_to_color([28/255, 35/255, 31/255])

class FreeGroupTreeScene(VoiceoverScene):
    def construct(self):
        self.set_speech_service(GTTSService(lang="en", tld="com"))

        title_card_tex = Tex(r"The free group $F_2$", font_size = 60)
        
        s = "One of the essential constructions in the proof of the Banach-Tarski paradox is the use of the free group to “duplicate” the ball. We will see that the free group generated by two elements can be easily divided into parts, such that they can be shifted to create two copies of itself. This is in essence what we wil eventually be doing with the unit sphere. So what is the free group?"

        with self.voiceover(s):
            self.play(Write(title_card_tex))

        s = "Let's look at a definition. The free group f two generated by two elements sigma and tau is the group consisting of all finite products of sigma, tau and their inverses. The identity in this group is the empty product."
        f2_definition_tex = Tex(r"\textbf{Definition (Free Group $F_2$)}. The free group $F_2$ generated by two elements $\sigma, \tau$ is the group consisting of all finite products of $\sigma, \tau$ and their inverses $\sigma^{-1}, \tau^{-1}$. The identity in this group is the empty product (denoted $e$).").scale(.75)

        with self.voiceover(s):
            self.play(
                title_card_tex.animate.to_edge(UP)
            )
            self.play(FadeIn(f2_definition_tex))

        s = "These are some examples of elements."
        example_elements_tex = Tex(r"Ex.: $\sigma\tau$, $\tau^2\sigma^{-1}$, $\sigma\tau\sigma\tau^{-2}\sigma$, etc.").next_to(f2_definition_tex, DOWN).shift(DOWN * .75)

        self.wait(2)

        with self.voiceover(s):
            self.play(
                Write(example_elements_tex)
            )


        root = MathTex(r"e")
        leaves_1 = []
        branches_1 = []
        for i, label in enumerate((r"\sigma", r"\tau", r"\sigma^{-1}", r"\tau^{-1}")):
            leaf = MathTex(label).shift(1.5*DOWN + i * RIGHT*2 - 3 * RIGHT)
            leaf_branch = Arrow(start = root, end = leaf)
            # leaf_branch_label = MathTex(label).next_to(leaf_branch, LEFT)#.shift(LEFT * .5)
            leaves_1.append(leaf)
            branches_1.append(leaf_branch)

        tree = VGroup(root, *leaves_1, *branches_1).to_edge(UP)

        leaves_2 = []
        branches_2 = []
        for i, label in enumerate((r"\sigma^2", r"\sigma\tau", r"\sigma\tau^{-1}")):
            leaf = MathTex(label).shift(i * RIGHT*2 - 3 * RIGHT)
            leaf_branch = Arrow(start = leaves_1[0], end = leaf)
            # leaf_branch_label = MathTex(label).next_to(leaf_branch, LEFT)#.shift(LEFT * .5)
            leaves_2.append(leaf)
            branches_2.append(leaf_branch)
        tree.add(*leaves_2, *branches_2)
        
        leaves_3 = []
        branches_3 = []
        for i, label in enumerate(
                (r"\sigma\tau\sigma", r"\sigma\tau^2", r"\sigma\tau\sigma^{-1}")
            ):
            leaf = MathTex(label).shift(2 * DOWN + i * RIGHT*2 - 3 * RIGHT)
            leaf_branch = Arrow(start = leaves_2[1], end = leaf)
            # leaf_branch_label = MathTex(label).next_to(leaf_branch, LEFT)#.shift(LEFT * .5)
            leaves_3.append(leaf)
            branches_3.append(leaf_branch)
        tree.add(*leaves_3, *branches_3)
        
        
        tree_text = Tex(r"$F_2$ as a tree").to_corner(UP + LEFT)

        s = "One way to look at this group is to consider it as a directed tree. At the root of the tree, we have the identity element e. We can then go further down the tree by multiplying on the right with sigma, sigma inverse, tau or tau inverse."
        with self.voiceover(s):
            self.play(
                    FadeOut(title_card_tex, f2_definition_tex, example_elements_tex),
                    Create(tree),
                    FadeIn(tree_text),
                    run_time = 2.5           
                )
            
        s = "Each step down the tree is a multiplication on the right by some element of F2. Note that we only looked at the progression of the tree for words starting with sigma, then starting with sigma tau. You should imagine the tree continuing infinitely for all the other branches as well. "

        with self.voiceover(s):
            self.wait(0.5)

        f2_decomp_tex = MathTex(r"F_2 = {{ \{e\} }} \cup {{W(\sigma)}} \cup {{W(\sigma^{-1})}} \cup {{W(\tau)}} \cup {{W(\tau^{-1})}}", font_size = 35).next_to(tree, DOWN, buff = 0.5)
        tree = VGroup(tree, f2_decomp_tex)

        s = "We can represent the same thing symbolically as follows. F2 can be written as"
        with self.voiceover(s):
            pass

        s = "the disjoint union of the empty word, all the elements starting with sigma, the elements starting with sigma inverse, the elements starting with tau, and the elements starting with tau inverse. The notation W of sigma means all elements starting with sigma."
        with self.voiceover(s):
            self.play(ShowIncreasingSubsets(f2_decomp_tex), run_time = 5)

        sigma_tree = VGroup(leaves_1[0], *leaves_2, *leaves_3, *branches_2, *branches_3) 
        sigma_tree_copy = sigma_tree.copy().move_to(sigma_tree.get_center())
        sigma_tree_leaves = VGroup(leaves_1[0], *leaves_2, *leaves_3)
        sigma_tree_copy_leaves = [m for m in sigma_tree_copy if type(m) == MathTex]

        f2_decomp_tex_sigma = MathTex(r"W(\sigma)").next_to(sigma_tree_copy, DOWN, buff = 0.5)
        sigma_tree_copy = VGroup(sigma_tree_copy, f2_decomp_tex_sigma)

        s = "Now let's take a closer look at the branch that has elements starting with sigma."
        with self.voiceover(s):
            self.play(
                LaggedStartMap(Indicate, sigma_tree_leaves, run_time = 2)
            )
            self.play(
                LaggedStartMap(Indicate, sigma_tree_leaves, run_time = 2)
            )
            self.play(
                tree.animate.to_edge(LEFT), 
                # f2_decomp_tex.animate.to_edge(LEFT),
                FadeOut(tree_text)
            )
            # self.play(f2_decomp_tex.animate.scale(.5), run_time=0.5)
            self.play(
                sigma_tree_copy.animate.to_edge(RIGHT),
                # f2_decomp_tex_sigma.animate.to_edge(RIGHT)    
            )

        self.wait(2)

        new_leaves = [
            r"e",
            r"\sigma", r"\tau", r"\tau^{-1}",
            r"\tau\sigma", r"\tau^{2}", r"\tau\sigma^{-1}"
        ]
        sigma_inv_tex = MathTex(r"\sigma^{-1}", color=BLUE).next_to(f2_decomp_tex_sigma, LEFT, buff = 0.07)
        s = "Notice that when, for all these elements, we multiply on the left by sigma inverse, we get the whole tree again!"
        with self.voiceover(s):
            self.play(FadeIn(sigma_inv_tex))
            notice_group = VGroup(sigma_inv_tex, f2_decomp_tex_sigma)
            self.play(Circumscribe(notice_group), run_time=2)
            self.wait(2)
            for i, leaf in enumerate(sigma_tree_copy_leaves):
                leaf_sigma_inv_tex = MathTex(r"\sigma^{-1}", font_size = 42, color=BLUE).next_to(leaf, LEFT, buff = 0.07).shift(UP * 0.03)
                self.play(Write(leaf_sigma_inv_tex), run_time=0.7)
                replacement_leaf = MathTex(new_leaves[i]).move_to(leaf.get_center())
                self.play(
                    FadeOut(leaf_sigma_inv_tex),
                    Transform(leaf, replacement_leaf),
                    run_time=0.7
                )
        
        s = "Or rather, we get almost the whole tree. The part of the tree that shows elements starting with sigma inverse is not there!"
        with self.voiceover(s):
            self.wait(3)
        
        self.play(FadeOut(*self.mobjects))

        self.wait(2)

class FreeGroupConclusionScene(VoiceoverScene):
    def construct(self):
        self.set_speech_service(GTTSService(lang="en", tld="com"))
        title = Title(r"The paradoxical decomposition of $F_2$", font_size = 1.5 * DEFAULT_FONT_SIZE).to_edge(UP)
        self.add(title)

        s = "So what we can conclude from all the trees is the following."
        with self.voiceover(s): pass
        s = "If we multiply all elements in F2 starting with sigma by sigma inverse on the left, we get all of the free group, except the elements starting with sigma inverse."
        decomp_tex = MathTex(r"\sigma^{-1}W(\sigma) = F_2 \setminus W(\sigma^{-1})").shift(UP)
        with self.voiceover(s):
            self.play(Write(decomp_tex))

        decomp_tex_2 = MathTex(r"F_2 = \sigma^{-1}{{W(\sigma)}} \cup {{W(\sigma^{-1})}}").next_to(decomp_tex, DOWN, buff=3*DEFAULT_MOBJECT_TO_MOBJECT_BUFFER)
        s = "This is of course equivalent to saying that F2 is the union of sigma inverse W sigma and W sigma inverse"
        with self.voiceover(s):
            self.play(Write(decomp_tex_2))
        self.wait(1)
        decomp_tex_3 = MathTex(r"F_2 = \tau^{-1}{{W(\tau)}} \cup {{W(\tau^{-1})}}").next_to(decomp_tex_2, DOWN)
        s = "But the choice for sigma was arbitrary, we could have just as well chosen to looked at the subtree of elements starting with tau."
        with self.voiceover(s): pass
        s = "So we also have that F2 is the union of tau inverse W tau and W tau inverse"
        with self.voiceover(s):
            self.play(Write(decomp_tex_3))
        

        f2_decomp_tex = MathTex(r"F_2 = {{ \{e\} }} \cup {{W(\sigma)}} \cup {{W(\sigma^{-1})}} \cup {{W(\tau)}} \cup {{W(\tau^{-1})}}").next_to(decomp_tex_3, DOWN, buff = 1)
        s = "Let's look at the original partition of F2 that we made."
        with self.voiceover(s):
            self.play(Write(f2_decomp_tex))
        
        s = "Notice that the parts in the original partition are now disjointly used in the two new partitions that we have found."
        with self.voiceover(s):    
            for obj, tex_element, color in [
                (decomp_tex_2, r"W(\sigma)", RED),
                (decomp_tex_2, r"W(\sigma^{-1})", BLUE),
                (decomp_tex_3, r"W(\tau)", ORANGE),
                (decomp_tex_3, r"W(\tau^{-1})", PINK),
            ]:
                self.play(
                    obj.animate.set_color_by_tex(tex_element, color),
                    f2_decomp_tex.animate.set_color_by_tex(tex_element, color)
                )

        conclusion_tex = Tex(r"We found a \textit{paradoxical decomposition} of $F_2$").next_to(f2_decomp_tex, DOWN)
        s = "So what we have now is called a paradoxical decomposition. We have split the free group F2 into five parts, took four of them and sort of shifted two of those parts to create two copies of F2. This is called a paradoxical decomposition"
        with self.voiceover(s):
            self.play(FadeIn(conclusion_tex))

        self.wait(2)