# Goal: show independent rotations in R3

from manim import *
from manim_voiceover import VoiceoverScene
from manim_voiceover.services.recorder import RecorderService
from manim.utils.color import Colors
import random
from math import sqrt, acos

config.background_color = rgb_to_color([28/255, 35/255, 31/255])
random.seed(14)

SIGMA = 0
TAU = 1
SIGMA_I = 2
TAU_I = 3


def get_random_point_on_sphere(radius):
    rand_x = random.uniform(-1, 1)
    rand_y = random.uniform(-sqrt(1 - rand_x**2), sqrt(1 - rand_x**2))
    rand_z = sqrt(1 - (rand_x**2 + rand_y**2)) * random.choice([-1, 1])
    return [radius * rand_x, radius * rand_y, radius * rand_z]

def get_point_string(point):
    x, y, z = point.get_center()
    return f"({x:.2f}, {y:.2f}, {z:.2f})"

def axis_angle_from_rotation_component(component):
    axis_of_rotation = RIGHT
    rotation_angle = 0
    if component == SIGMA:
        axis_of_rotation = RIGHT
        rotation_angle = acos(1/3)
    elif component == SIGMA_I:
        axis_of_rotation = RIGHT
        rotation_angle = -acos(1/3)
    elif component == TAU:
        axis_of_rotation = UP
        rotation_angle = acos(1/3)
    elif component == TAU_I:
        axis_of_rotation = UP
        rotation_angle = -acos(1/3)
    return axis_of_rotation, rotation_angle

rotation_translation_dict = {
    SIGMA: r"\sigma",
    SIGMA_I: r"\sigma^{-1}",
    TAU: r"\tau",
    TAU_I: r"\tau^{-1}", 
}

class HowToTransferScene(VoiceoverScene):
    def construct(self):
        self.set_speech_service(RecorderService(silence_threshold=-40.0))
        
        title = Title("Why do we care about $F_2$ at all?")
        self.add(title)


        # show decompositions 
        f2_decomp_tex = MathTex(r"\tau^{-1}{{W(\tau)}} \cup {{W(\tau^{-1})}} = F_2 = \sigma^{-1}{{W(\sigma)}} \cup {{W(\sigma^{-1})}}")
        f2_decomp_toelichting = Tex("Paradoxical decomposition of $F_2$").next_to(f2_decomp_tex, UP)
        f2_decomp = VGroup(f2_decomp_tex, f2_decomp_toelichting).shift(UP)

        s2_decomp_tex = MathTex(r"\tau^{-1}{{W(\tau)}}M \cup {{W(\tau^{-1})}}M = S^2 \setminus D = \sigma^{-1}{{W(\sigma)}}M \cup {{W(\sigma^{-1})}}M")
        s2_decomp_toelichting = Tex("Paradoxical decomposition of $S^2 \setminus D$").next_to(s2_decomp_tex, DOWN)
        s2_decomp_toelichting_nog_meer = Tex("($D$ is a set of problematic points, and $M \subset S^2$)").next_to(s2_decomp_toelichting, DOWN)
        s2_decomp = VGroup(s2_decomp_tex, s2_decomp_toelichting, s2_decomp_toelichting_nog_meer).shift(DOWN * 1.5)

        arrow = Arrow(start=UP, end=DOWN).shift(DOWN*0.25)

        for tex_element, color in [
                (r"W(\sigma)", RED),
                (r"W(\sigma^{-1})", BLUE),
                (r"W(\tau)", ORANGE),
                (r"W(\tau^{-1})", PINK),
            ]:
                f2_decomp_tex.set_color_by_tex(tex_element, color)
                s2_decomp_tex.set_color_by_tex(tex_element, color)

        s = "You might wonder how this paradoxical decomposition of the Free Group will help us in proving the Banach-Tarski paradox."
        with self.voiceover(s):
            self.play(FadeIn(f2_decomp))

        s = "We can transfer the paradoxical decomposition of the Free Group to the points of the unit sphere almost directly using independent rotations that behave identically to the Free Group. Sigma, tau, and their products will then represent certain rotations. We will see these soon"
        with self.voiceover(s):
            self.play(FadeIn(arrow, s2_decomp))
        
        s = "You might notice that the paradoxical decomposition is not of the whole sphere; this is because we need to remove a set of problematic points D from the sphere to make the transfer work. We will see later exactly which points these are."
        with self.voiceover(s):
            pass

        s = "You will also see that there is a subset M of the unit sphere that we will apply those rotations to. This is not just any set; we will need to pick it carefully so that this transfer works."
        with self.voiceover(s):
            pass

class IndependentRotations(VoiceoverScene, ThreeDScene):
    def construct(self):
        self.set_speech_service(RecorderService(silence_threshold=-40.0))

        title = Title(r"Independent rotations in $\mathbb{E}_3$")
        
        s = "As mentioned before, to transfer the decomposition from the free group, we need two independent rotations in the Euclidian group E_3 to form a group generated by these two rotations. We can then transfer the decomposition for the free group onto the sphere S2 by applying those rotations to the sphere."
        with self.voiceover(s):
            self.play(Write(title))

        # show rotations acos(1/3) along x/y axis. 
        sigma_tex = MathTex(r"\sigma = \begin{pmatrix} 1 & 0 & 0 \\ 0 & \frac{1}{3} & -\frac{2\sqrt{2}}{3} \\ 0 & \frac{2\sqrt{2}}{3} & \frac{1}{3} \end{pmatrix}", font_size = 55)
        sigma_comment_tex = Tex(r"$\arccos(\frac{1}{3})$ rad around the x-axis", font_size=35)
        sigma_group = VGroup(sigma_tex, sigma_comment_tex).arrange(DOWN)
        tau_tex = MathTex(r"\tau = \begin{pmatrix} \frac{1}{3} & \frac{2\sqrt{2}}{3} & 0\\ -\frac{2\sqrt{2}}{3} & \frac{1}{3} & 0 \\ 0 & 0 & 1 \end{pmatrix}", font_size=55)
        tau_comment_tex = Tex(r"$\arccos(\frac{1}{3})$ rad around the y-axis", font_size=35)
        tau_group = VGroup(tau_tex, tau_comment_tex).arrange(DOWN)
        rotations = VGroup(sigma_group, tau_group).arrange(RIGHT)

        
        s = "Let's look at an example of two such rotations. These are the rotations around the x and y axes by an angle of the arc cosine of one third. We will call the rotation around the x-axis sigma, and the rotation along the y-axis tau."
        with self.voiceover(s):
            self.play(Write(rotations))

        s = "We will refer to this group of rotations as G sigma tau"
        group_rotations = MathTex(r"G(\sigma, \tau)").to_edge(DOWN)
        with self.voiceover(s):
            self.play(Write(group_rotations))

        self.wait(2)

class TauRotation(VoiceoverScene, ThreeDScene):
    def construct(self):
        self.set_speech_service(RecorderService(silence_threshold=-40.0))

        self.set_camera_orientation(phi=65 * DEGREES, theta=225 * DEGREES, zoom=.75, run_time=1.5)
        self.begin_ambient_camera_rotation(rate=0.4)
        title = Tex(r"Rotation $\tau$ (along the $y$-axis)").to_edge(UP)
        self.add_fixed_in_frame_mobjects(title)

        axes = ThreeDAxes()

        x_label = axes.get_x_axis_label(Tex(r"x"))
        y_label = axes.get_y_axis_label(Tex(r"y", color=RED)).shift(UP * 1.8)
        z_label = axes.get_z_axis_label(Tex(r"z"), rotation=-PI/2).shift(OUT*.25)

        sphere_radius = 2.5
        sphere = Sphere(radius=sphere_radius, fill_opacity=.5).set_color(BLUE)

        start = 0
        end = start+np.arccos(1/3)
        eps = 0.05
        sphere_radius_expanded = sphere_radius + 0.25
        arrow_curve = ParametricFunction(
                    lambda t: np.array([
                        -sphere_radius_expanded*np.cos(t),
                        0,
                        sphere_radius_expanded*np.sin(t)
                    ]), color=PINK, t_range=[start, end],
                ).set_shade_in_3d(True)
        arrow_curve.stroke_width = 5
        arrow_cone = Cone(show_base=True, base_radius=0.15, height=0.5, direction=[np.sin(end+eps), 0, np.cos(end+eps)]).shift([-sphere_radius_expanded*np.cos(end+eps), 0, sphere_radius_expanded*np.sin(end+eps)]).set_color(PINK)

        self.add(title, sphere, axes, x_label, y_label, z_label, arrow_curve, arrow_cone)
        
        s = "The rotation tau looks as follows when applied to the sphere"
        with self.voiceover(s):
            for _ in range(3):
                self.play(Rotate(sphere, np.arccos(1/3), UP), run_time=3)
                sphere.rotate(-np.arccos(1/3), UP)
        
        self.wait(2)

class SigmaRotation(VoiceoverScene, ThreeDScene):
    def construct(self):
        self.set_speech_service(RecorderService(silence_threshold=-40.0))

        self.set_camera_orientation(phi=65 * DEGREES, theta=135 * DEGREES, zoom=.75, run_time=1.5)
        self.begin_ambient_camera_rotation(rate=0.4)
        title = Tex(r"Rotation $\sigma$ (along the $x$-axis)").to_edge(UP)
        self.add_fixed_in_frame_mobjects(title)

        axes = ThreeDAxes()

        x_label = axes.get_x_axis_label(Tex(r"x", color=RED))
        y_label = axes.get_y_axis_label(Tex(r"y")).shift(UP * 1.8)
        z_label = axes.get_z_axis_label(Tex(r"z"), rotation=-PI/2).shift(OUT*.25)

        sphere_radius = 2.5
        sphere = Sphere(radius=sphere_radius, fill_opacity=.5).set_color(BLUE)

        start = 0
        end = start+np.arccos(1/3)
        eps = 0.05
        sphere_radius_expanded = sphere_radius + 0.25
        arrow_curve = ParametricFunction(
                    lambda t: np.array([
                        0,
                        sphere_radius_expanded*np.cos(t),
                        sphere_radius_expanded*np.sin(t)
                    ]), color=PINK, t_range=[start, end],
                ).set_shade_in_3d(True)
        arrow_curve.stroke_width = 5
        arrow_cone = Cone(show_base=True, base_radius=0.15, height=0.5, direction=[0, -np.sin(end+eps), np.cos(end+eps)]).shift([0, sphere_radius_expanded*np.cos(end+eps), sphere_radius_expanded*np.sin(end+eps)]).set_color(PINK)

        self.add(title, sphere, axes, x_label, y_label, z_label, arrow_curve, arrow_cone)
        
        s = "Let's quickly look at what these two rotations look like by seeing how they apply to the unit sphere."
        with self.voiceover(s):
            pass

        s = "The rotation sigma looks as follows when applied to the sphere"
        with self.voiceover(s):
            for _ in range(3):
                self.play(Rotate(sphere, np.arccos(1/3), RIGHT), run_time=3)
                sphere.rotate(-np.arccos(1/3), RIGHT)
        
        self.wait(2)

class IndependenceConclusion(VoiceoverScene):
    def construct(self):
        s = "Independence important because"

        s = "Group generated by these rotations, which is isomorphic to the free group (that is, it behaves exactly the same)"